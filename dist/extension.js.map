{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://go-inline-pgformatter/external commonjs \"vscode\"","webpack://go-inline-pgformatter/external node-commonjs \"child_process\"","webpack://go-inline-pgformatter/external node-commonjs \"fs\"","webpack://go-inline-pgformatter/external node-commonjs \"os\"","webpack://go-inline-pgformatter/webpack/bootstrap","webpack://go-inline-pgformatter/./src/extension.ts"],"sourcesContent":["module.exports = require(\"vscode\");","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport { execSync } from 'child_process';\nimport * as vscode from 'vscode';\nimport { promises as fs } from 'fs';\n\nconst keywords = [\"update\", \"select\", \"insert\", \"into\", \"delete\", \"from\", \"where\"];\nconst sqlSplitMarker = \"\\n-- go-inline-pgformatter-splitmark\\n\";\nconst builtinPgFormat = \"/.vscode/extensions/passioinc.go-inline-pgformatter-\";\n\nconst keywordCaseOptions = [\n\t\"leaves all pgSql keywords in the casing they are currently in\",\n\t\"changes allpgSql keywords to lowercase\",\n\t\"changes allpgSql keywords to UPPERCASE\",\n\t\"changes allpgSql keywords to Capitalized\"\n];\n\n// see if path exists on disk\nasync function exists (path : string) {  \n\ttry {\n\t  await fs.access(path);\n\t  return true;\n\t} catch {\n\t  return false;\n\t}\n  }\n\n// check if text block is SQL\nfunction likelySql(s: string) {\n\tconst matches = keywords.filter(element => {\n\t\treturn (s.toLowerCase()).includes(element);\n\t});\n\treturn matches.length >= 2;\n}\n\n// this method is called when your extension is activated\n// your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n\n\t// Use the console to output diagnostic information (console.log) and errors (console.error)\n\t// This line of code will only be executed once when your extension is activated\n\tconsole.log('Congratulations, your extension \"go-inline-pgformatter\" is now active!');\n\n\t// The command has been defined in the package.json file\n\t// Now provide the implementation of the command with registerCommand\n\t// The commandId parameter must match the command field in package.json\n\tlet disposable = vscode.commands.registerCommand('go-inline-pgformatter.formatAllSql', () => {\n\n\t\t// path settings\n\t\tconst homedir = require('os').homedir();\n\t\tconst config = vscode.workspace.getConfiguration(\"goPgFormat\");\n\t\tconst pgFormatPathUser = config.get(\"pgFormatPath\");\n\n\t\t// get meta values like the version\n\t\tconst packageMeta = require('../package.json');\n\n\t\t// expand our built-in pg_format path, or grab the users and make them str\n\t\tvar pgFormatPath = \"\";\n\t\tif (`${pgFormatPathUser}` === \"\") {\n\t\t\tpgFormatPath = `${homedir}${builtinPgFormat}${packageMeta.version}/pg_format`;\n\t\t}\n\t\telse {\n\t\t\tpgFormatPath = `${pgFormatPathUser}`;\n\t\t}\n\n\t\t// async promise to check if we have pg format\n\t\tvar pgExists = (async () => await exists(`${pgFormatPath}`))();\n\n\t\tpgExists.then(function (response) {\n\t\t\t// if no pg_format path, we cant work!\n\t\t\tif (!response) {\n\t\t\t\tvscode.window.showErrorMessage(`Path to pg_format does not exist:\\n${pgFormatPath}`);\t\n\t\t\t\treturn new Promise(function(){return true;});\n\t\t\t}\n\t\t\t// set up\n\t\t\tconst { activeTextEditor } = vscode.window;\n\t\n\t\t\t// only run on golang\n\t\t\tif (activeTextEditor && activeTextEditor.document.languageId === 'go') {\n\t\t\t\t\n\t\t\t\t// create an edit to store in\n\t\t\t\tconst edit = new vscode.WorkspaceEdit();\n\n\t\t\t\t// grab some preference values\n\t\t\t\tconst matchSpacing = config.get(\"matchSpacing\");\t\t\n\t\t\t\tconst keywordCase = config.get(\"keywordCase\");\t\t\n\t\t\t\tconst addTabsValue = config.get(\"addTabs\");\n\t\t\t\tvar addTabs = 0;\n\t\t\t\tif (typeof addTabsValue === 'number') {\n\t\t\t\t\taddTabs = addTabsValue;\t\n\t\t\t\t}\n\n\t\t\t\t// get the active document\n\t\t\t\tconst { document } = activeTextEditor;\n\t\n\t\t\t\t// loop vars\n\t\t\t\tvar startLine = null;\n\t\t\t\tvar endLine = null;\t\n\t\n\t\t\t\t// info message counter\n\t\t\t\tvar sqlStringsUpdated = 0;\n\n\t\t\t\t// takes way too long to run the subproc like 12 times if we have 12 strings. Combine them all into one input, stdout once\n\t\t\t\t// and well deal with remapping later\n\t\t\t\tvar allSql = \"\";\n\t\t\t\t// also need to store its edit range and start-line ref for our options\n\t\t\t\tvar editRanges = Array<vscode.Range>();\n\t\t\t\tvar lineRefs = Array<vscode.TextLine>();\n\t\n\t\t\t\t// looping lines until we find a line with 2 backticks, or a line with one backtick and then keep searching\n\t\t\t\t// for a line with its ending backtick - get indicies of these characters\n\t\t\t\tfor (let li = 0; li < document.lineCount; li++) {\n\t\t\t\t\tconst element = document.lineAt(li);\n\t\n\t\t\t\t\t// find if this line has both backticks, or one\n\t\t\t\t\tlet ci = element.text.indexOf(\"`\");\n\t\t\t\t\tlet fi = element.text.lastIndexOf(\"`\");\n\t\t\t\t\tif (ci >= 0) {\n\t\t\t\t\t\tif (startLine === null) {\n\t\t\t\t\t\t\tstartLine = element;\n\t\t\t\t\t\t\tif (ci !== fi) {\n\t\t\t\t\t\t\t\tendLine = element;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tendLine = element;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// if start and line are fulfilled, we have a text block\n\t\t\t\t\tif (startLine !== null && endLine !== null) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// prep replacement range f backticks\n\t\t\t\t\t\tlet startChar = new vscode.Position(startLine.lineNumber, startLine.text.indexOf(\"`\") + 1);\n\t\t\t\t\t\tlet endChar = new vscode.Position(endLine.lineNumber, endLine.text.lastIndexOf(\"`\"));\n\t\t\t\t\t\t\n\t\t\t\t\t\t// get range, and the text from it\n\t\t\t\t\t\tlet textRange = new vscode.Range(startChar, endChar);\n\t\t\t\t\t\tlet allText = document.getText(textRange);\n\t\n\t\t\t\t\t\t// if the text in this range seems to be SQL lets get it ready for formatting\n\t\t\t\t\t\tif (likelySql(allText)) { \t\n\t\t\t\t\t\t\t//incris good\n\t\t\t\t\t\t\tsqlStringsUpdated += 1;\n\t\n\t\t\t\t\t\t\t// need to escape parameters or they break - also need to make sure the line ends with a single semi-colon or it thinks its all one statement\n\t\t\t\t\t\t\t// also changing %s to a custom string - so we dont break go fmts\n\t\t\t\t\t\t\tlet cleanedText = allText.replace(/\\$/g, \"\\\\$\").replace(/\\%/g, \"xxpggo\").replace(/;$/, \"\") + \";\";\n\n\t\t\t\t\t\t\t// add our markers for where to split each statement\n\t\t\t\t\t\t\tallSql += (cleanedText + sqlSplitMarker);\n\t\t\t\t\t\t\t// store vscode obj refs\n\t\t\t\t\t\t\teditRanges.push(textRange);\n\t\t\t\t\t\t\tlineRefs.push(startLine);\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// reset lines so we can find the next one\n\t\t\t\t\t\tstartLine = null;\n\t\t\t\t\t\tendLine = null;\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t}\t\n\n\t\t\t\t// run perl pg_format - insert our prefs\n\t\t\t\tlet caseIndex = keywordCaseOptions.indexOf(`${keywordCase}`);\n\t\t\t\tvar stdout = execSync(`echo \"${allSql}\" | perl ${pgFormatPath} --keyword-case ${caseIndex} --type-case ${caseIndex}`) ;\n\t\t\t\t\n\t\t\t\t// loop the stdout result split by our comment splitter, with some additional whitespace allowance after formatting\n\t\t\t\tvar c = 0;\n\t\t\t\tstdout.toString().split(/\\n\\s*-- go-inline-pgformatter-splitmark\\n/).forEach(sqlBlock => {\n\n\t\t\t\t\t// remove start/end whitespace, and reset our silly % sign marker, as we cant make pg_sql not format them\n\t\t\t\t\tlet replWith = sqlBlock.replace(/^[\\s\\n\\r]+|[\\s\\n\\r]+$/, \"\").replace(/xxpggo/g, \"%\").replace(/;$/, \"\");\n\t\t\t\t\t\n\t\t\t\t\t// we can get some empty blocks - skip them\n\t\t\t\t\tif (replWith === \"\" ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if user wants custom tabbing, do it\n\t\t\t\t\tif (matchSpacing) {\n\t\t\t\t\t\tlet indentedTo = lineRefs[c].firstNonWhitespaceCharacterIndex;\n\t\t\t\t\t\tlet insert = lineRefs[c].text.slice(0, indentedTo) + \"\\t\".repeat(addTabs);\t\t\t\t\t\t\t\n\t\t\t\t\t\treplWith = insert + replWith.replace(/\\n/g, \"\\n\" + insert);\n\t\t\t\t\t}\n\t\t\t\t\treplWith = \"\\n\" + replWith;\n\t\t\t\t\t\n\t\t\t\t\t// insert the edit and increment counter\n\t\t\t\t\tedit.replace(document.uri, editRanges[c], replWith);\t\n\t\t\t\t\tc += 1;\t\t\t\t\t\t\t\t\n\t\t\t\t});\t\t\t\t\n\t\t\t\t\n\t\t\t\t// sho info that this is going to work\t\t\t\t\t\t\t\t\n\t\t\t\tvscode.window.setStatusBarMessage(`Successfully formatted ${sqlStringsUpdated} pgSQL strings in-line!`);\t\t\t\n\t\t\t\treturn vscode.workspace.applyEdit(edit);\t\t\t\n\t\t\t}\n\t\t}).catch(function (error) {\n\t\t\t// error!\n\t\t\tvscode.window.showErrorMessage(`go-inline-pgformatter error: ${error}`);\t\t\t\n\t\t\treturn new Promise(function(){return false;});\t\t\n\t\t});\n\t});\n\n\tcontext.subscriptions.push(disposable);\n}\n\n// this method is called when your extension is deactivated\nexport function deactivate() { }\n"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","keywords","keywordCaseOptions","likelySql","s","filter","element","toLowerCase","includes","length","context","console","log","disposable","vscode","commands","registerCommand","homedir","config","workspace","getConfiguration","pgFormatPathUser","get","packageMeta","pgFormatPath","version","async","path","access","exists","then","response","window","showErrorMessage","Promise","activeTextEditor","document","languageId","edit","WorkspaceEdit","matchSpacing","keywordCase","addTabsValue","addTabs","startLine","endLine","sqlStringsUpdated","allSql","editRanges","Array","lineRefs","li","lineCount","lineAt","ci","text","indexOf","fi","lastIndexOf","startChar","Position","lineNumber","endChar","textRange","Range","allText","getText","replace","push","caseIndex","stdout","execSync","c","toString","split","forEach","sqlBlock","replWith","indentedTo","firstNonWhitespaceCharacterIndex","insert","slice","repeat","uri","setStatusBarMessage","applyEdit","catch","error","subscriptions"],"sourceRoot":""}